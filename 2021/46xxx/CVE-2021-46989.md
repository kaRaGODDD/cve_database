
# [CVE-2021-46989](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-46989)

## Description

- `In the Linux kernel, the following vulnerability has been resolved:hfsplus: prevent corruption in shrinking truncateI believe there are some issues introduced by commit 31651c607151("hfsplus: avoid deadlock on file truncation")HFS+ has extent records which always contains 8 extents.  In case thefirst extent record in catalog file gets full, new ones are allocated fromextents overflow file.In case shrinking truncate happens to middle of an extent record whichlocates in extents overflow file, the logic in hfsplus_file_truncate() waschanged so that call to hfs_brec_remove() is not guarded any more.Right action would be just freeing the extents that exceed the new sizeinside extent record by calling hfsplus_free_extents(), and then check ifthe whole extent record should be removed.  However since the guard(blk_cnt > start) is now after the call to hfs_brec_remove(), this hasunfortunate effect that the last matching extent record is removedunconditionally.To reproduce this issue, create a file which has at least 10 extents, andthen perform shrinking truncate into middle of the last extent record, sothat the number of remaining extents is not under or divisible by 8.  Thiscauses the last extent record (8 extents) to be removed totally instead oftruncating into middle of it.  Thus this causes corruption, and lost data.Fix for this is simply checking if the new truncated end is below thestart of this extent record, making it safe to remove the full extentrecord.  However call to hfs_brec_remove() can't be moved to it's previousplace since we're dropping ->tree_lock and it can cause a race conditionand the cached info being invalidated possibly corrupting the node data.Another issue is related to this one.  When entering into the block(blk_cnt > start) we are not holding the ->tree_lock.  We break out fromthe loop not holding the lock, but hfs_find_exit() does unlock it.  Notsure if it's possible for someone else to take the lock under our feet,but it can cause hard to debug errors and premature unlocking.  Even ifthere's no real risk of it, the locking should still always be kept inbalance.  Thus taking the lock now just before the check.`

## Cvss Data

- **Access Vector**:
  - 
- **Base Score**:
  - 

## Scores

- **Exploitability Score**:
  - 
- **Impact Score**:
  - 
- **Base Severity**:
  - 

## Other Information

- **Publish Date**:
  - 2024-02-28 09:15:37
- **Vulnerability Status**:
  - Awaiting Analysis

## References

- **416baaa9-dc9f-4396-8d5f-8c081fb06d67**: https://git.kernel.org/stable/c/52dde855663e5db824af51db39b5757d2ef3e28a
- **416baaa9-dc9f-4396-8d5f-8c081fb06d67**: https://git.kernel.org/stable/c/97314e45aa1223a42d60256a62c5d9af54baf446
- **416baaa9-dc9f-4396-8d5f-8c081fb06d67**: https://git.kernel.org/stable/c/adbd8a2a8cc05d9e501f93e5c95c59307874cc99
- **416baaa9-dc9f-4396-8d5f-8c081fb06d67**: https://git.kernel.org/stable/c/c3187cf32216313fb316084efac4dab3a8459b1d
- **416baaa9-dc9f-4396-8d5f-8c081fb06d67**: https://git.kernel.org/stable/c/c451a6bafb5f422197d31536f82116aed132b72c
- **416baaa9-dc9f-4396-8d5f-8c081fb06d67**: https://git.kernel.org/stable/c/c477f62db1a0c0ecaa60a29713006ceeeb04b685
